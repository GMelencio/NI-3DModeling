
<!DOCTYPE html>
<html lang="en">
<head>
    <title>3D Spheres Drawing Demo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #000;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            font-weight: bold;
            background-color: #fff;
            margin: 0px;
            overflow: hidden;
        }

        #fingercoords {
            color: #000;
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 5px;
        }
        
        #spherecoords {
            color: #000;
            position: absolute;
            top: 18px;
            width: 100%;
            padding: 5px;
        }

        div.instructions {
            font-size: 14pt;
            color: black;
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <div id="fingercoords"></div>
    <div id="spherecoords"></div>
    

    <script src="http://threejs.org/build/three.min.js"></script>
    <script src="http://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="http://threejs.org/examples/js/Detector.js"></script>
    <script src="http://threejs.org/examples/js/libs/stats.min.js"></script>
    <script src="http://js.leapmotion.com/leap-0.6.4.min.js"></script>
    <script src="http://js.leapmotion.com/leap-plugins-0.1.10.min.js"></script>
    <script src="http://js.leapmotion.com/leap.rigged-hand-0.1.5.min.js"></script>

    <script>
        var sphereSize = 5;
        var spheresDrawn = [];

        var riggedHandPlugin;

        if (!Detector.webgl) Detector.addGetWebGLMessage();

        var container, stats;
        var camera, controls, scene, renderer;

        init();
        render();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
        }

        function init() {
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 500;

            controls = new THREE.OrbitControls(camera);
            controls.damping = 0.2;
            controls.addEventListener('change', render);

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xcccccc, 0.002);

            // Create the cones to provide perspective
            createRandomCones(30, scene);

            // Create the lights
            createSceneLighting(scene);

            // renderer
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setClearColor(scene.fog.color, 1);
            renderer.setSize(window.innerWidth, window.innerHeight);

            container = document.getElementById('container');
            container.appendChild(renderer.domElement);

            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';
            stats.domElement.style.zIndex = 100;
            container.appendChild(stats.domElement);

            //
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        function createSceneLighting(targetScene) {
            light = new THREE.DirectionalLight(0xffffff);
            light.position.set(1, 1, 1);
            targetScene.add(light);

            light = new THREE.DirectionalLight(0x002288);
            light.position.set(-1, -1, -1);
            targetScene.add(light);

            light = new THREE.AmbientLight(0x222222);
            targetScene.add(light);
        }

        function createRandomCones(coneCount, targetScene) {
            var geometry = new THREE.CylinderGeometry(0, 10, 30, 4, 1);
            var material = new THREE.MeshLambertMaterial({ color: 0xffffff, shading: THREE.FlatShading });

            for (var i = 0; i < coneCount; i++) {
                var mesh = new THREE.Mesh(geometry, material);
                mesh.position.x = (Math.random() - 0.5) * 1000;
                mesh.position.y = (Math.random() - 0.5) * 1000;
                mesh.position.z = (Math.random() - 0.5) * 1000;
                mesh.updateMatrix();
                mesh.matrixAutoUpdate = false;
                targetScene.add(mesh);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

            render();
        }

        function render() {
            requestAnimationFrame(render);
            renderer.render(scene, camera);
            stats.update();
        }


        //Leap and drawing functions follow
        Leap.loop(
          function (frame) {

              frame.hands.forEach(
                function (hand) {
                    TryDrawObject(hand)
                }
           )
          }
       )
        .use('riggedHand')
        .use('handEntry')

        riggedHandPlugin = Leap.loopController.plugins.riggedHand;


        //This method will draw a 2D or 3D object based on whether or not the recognized gesture is used and 
        //The object will be drawn at the where the gesture is performed
        function TryDrawObject(hand) {
            var extendedFingers = getExtendedFingers(hand);

            //Draw mode is defined as having only the index finger extended
            var isInDrawMode = extendedFingers.length == 1 && hand.indexFinger.extended
            //Draw mode is defined as having only the pinky finger extended
            var isInClearMode = extendedFingers.length == 1 && hand.pinky.extended

            if (isInDrawMode) {
                var indexFinger = extendedFingers[0];
                var pos = indexFinger.tipPosition;
                var handMesh = hand.data('riggedHand.mesh');
                
                var xcoord = indexFinger.stabilizedTipPosition[0];
                var ycoord = indexFinger.stabilizedTipPosition[1];
                var zcoord = indexFinger.stabilizedTipPosition[2];

                var xpos = " X : " + xcoord;
                var ypos = " Y : " + ycoord;
                var zpos = " Z : " + zcoord;

                updateCoordsLabel("fingercoords", "Drawing requested at " + xpos.substring(0, 7) + ypos.substring(0, 7) + zpos.substring(0, 7));
                var sphere = createSphere(sphereSize, xcoord, ycoord, zcoord);
                addSphereToScene(sphere, scene, false);
                spheresDrawn.push(sphere);
            }
            else if (isInClearMode) {
                clearDrawing(hand);
            }
            else {
                updateCoordsLabel("fingercoords", "You are not drawing right now");
            }

        }

        function clearDrawing(hand) {
            spheresDrawn.forEach(function (sphere) { scene.remove(sphere); })
            spheresDrawn = [];
        }

        //Draws a 3D dimensional object (sphere for now) of a given size and at the specified screen position
        function createSphere(size, xpos, ypos, zpos) {
            var geom = new THREE.SphereGeometry(size, 4, 4);
            var material = new THREE.MeshNormalMaterial({ color: 0x00fff0 })
            var sphere = new THREE.Mesh(geom, material)

            var adjustedPosition = calculate3DPosition(xpos, ypos, zpos);

            sphere.position.x = adjustedPosition.x;
            sphere.position.y = adjustedPosition.y;
            sphere.position.z = adjustedPosition.z;

            //Unsure if still needed:
            //sphere.updateMatrix();
            //sphere.matrixAutoUpdate = false;
            return sphere;
        }

        function addSphereToScene(sphere, targetScene, forceGeometryUpdates) {

            if (forceGeometryUpdates) {
                //From: http://aerotwist.com/tutorials/getting-started-with-three-js/
                // set the geometry to dynamic
                // so that it allow updates
                sphere.geometry.dynamic = true;

                // changes to the vertices
                sphere.geometry.verticesNeedUpdate = true;

                // changes to the normals
                sphere.geometry.normalsNeedUpdate = true;
            }

            targetScene.add(sphere);
            var xpos = "X: " + sphere.position.x;
            var ypos = "Y: " + sphere.position.y;
            var zpos = "Z: " + sphere.position.z;

            updateCoordsLabel("spherecoords", "Sphere # " + spheresDrawn.length + " drawn at " + xpos.substring(0, 7) + ", " + ypos.substring(0, 7) + ", " +  zpos.substring(0, 7));
        }

        //Calculates the 3D position for a 3D object for a given screen position
        function calculate3DPosition(screenPosX, screenPosY, screenPosZ) {
            /*
            //TODO: This is a total hack and works half the time, needs a lot of work to get it to "draw" the object in the right place
            if (useOffesets) {
                var xpos = screenPosX - (window.innerWidth / 2);
                var ypos = screenPosY - (window.innerHeight / 2) + 100;
                var zpos = ((((screenPosZ * -100000) + 99000)) / 7);
                return new THREE.Vector3(xpos, ypos, zpos);
            }
            else 
            */
                return new THREE.Vector3(screenPosX, screenPosY, screenPosZ * 1.15);
        }

        //Helper method to write out debug messages
        function updateCoordsLabel(elementid, message) {
            var coordslabel = document.getElementById(elementid);
            coordslabel.innerHTML = message;
        }

        //Gets the number of extended fingers for a given hand (seems more relaible than the built-in leap function to check)
        function getExtendedFingers(hand) {
            var extendedFingers = [];
            hand.fingers.forEach(function (finger) {
                if (finger.extended)
                    extendedFingers.push(finger);
            });

            return extendedFingers;
        }

    </script>

</body>
</html>
